;;;----------------------------------------------------------------------------------
;;; Generated by protoc-gen-clojure.  DO NOT EDIT
;;;
;;; Message Implementation of package protojure.test.grpc
;;;----------------------------------------------------------------------------------
(ns protojure.test.grpc
  (:require [protojure.protobuf.protocol :as pb]
            [protojure.protobuf.serdes.core :as serdes.core]
            [protojure.protobuf.serdes.complex :as serdes.complex]
            [protojure.protobuf.serdes.utils :refer [tag-map]]
            [protojure.protobuf.serdes.stream :as serdes.stream]
            [com.google.protobuf :as com.google.protobuf]
            [clojure.set :as set]
            [clojure.spec.alpha :as s]))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Forward declarations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(declare cis->CloseDetectRequest)
(declare ecis->CloseDetectRequest)
(declare new-CloseDetectRequest)
(declare cis->FlowControlRequest)
(declare ecis->FlowControlRequest)
(declare new-FlowControlRequest)
(declare cis->FlowControlPayload)
(declare ecis->FlowControlPayload)
(declare new-FlowControlPayload)
(declare cis->SimpleResponse)
(declare ecis->SimpleResponse)
(declare new-SimpleResponse)
(declare cis->ErrorRequest)
(declare ecis->ErrorRequest)
(declare new-ErrorRequest)
(declare cis->BigPayload)
(declare ecis->BigPayload)
(declare new-BigPayload)
(declare cis->ShouldThrowRequest)
(declare ecis->ShouldThrowRequest)
(declare new-ShouldThrowRequest)
(declare cis->ShouldThrowResponse)
(declare ecis->ShouldThrowResponse)
(declare new-ShouldThrowResponse)

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Enumerations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; BigPayload-Mode
;-----------------------------------------------------------------------------
(def BigPayload-Mode-default :mode-invalid)

(def BigPayload-Mode-val2label {
  0 :mode-invalid
  1 :mode-upload
  2 :mode-download
  3 :mode-bidi})

(def BigPayload-Mode-label2val (set/map-invert BigPayload-Mode-val2label))

(defn cis->BigPayload-Mode [is]
  (let [val (serdes.core/cis->Enum is)]
    (get BigPayload-Mode-val2label val val)))

(defn- get-BigPayload-Mode [value]
  {:pre [(or (int? value) (contains? BigPayload-Mode-label2val value))]}
  (get BigPayload-Mode-label2val value value))

(defn write-BigPayload-Mode
  ([tag value os] (write-BigPayload-Mode tag {:optimize false} value os))
  ([tag options value os]
   (serdes.core/write-Enum tag options (get-BigPayload-Mode value) os)))



;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Message Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; CloseDetectRequest
;-----------------------------------------------------------------------------
(defrecord CloseDetectRequest-record [id]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:id this) os))
  pb/TypeReflection
  (gettype [this]
    "protojure.test.grpc.CloseDetectRequest"))

(s/def :protojure.test.grpc.CloseDetectRequest/id string?)
(s/def ::CloseDetectRequest-spec (s/keys :opt-un [:protojure.test.grpc.CloseDetectRequest/id ]))
(def CloseDetectRequest-defaults {:id "" })

(defn cis->CloseDetectRequest
  "CodedInputStream to CloseDetectRequest"
  [is]
  (->> (tag-map CloseDetectRequest-defaults
         (fn [tag index]
             (case index
               1 [:id (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->CloseDetectRequest-record)))

(defn ecis->CloseDetectRequest
  "Embedded CodedInputStream to CloseDetectRequest"
  [is]
  (serdes.core/cis->embedded cis->CloseDetectRequest is))

(defn new-CloseDetectRequest
  "Creates a new instance from a map, similar to map->CloseDetectRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::CloseDetectRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::CloseDetectRequest-spec init))))]}
  (-> (merge CloseDetectRequest-defaults init)
      (map->CloseDetectRequest-record)))

(defn pb->CloseDetectRequest
  "Protobuf to CloseDetectRequest"
  [input]
  (cis->CloseDetectRequest (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record CloseDetectRequest-meta {:type "protojure.test.grpc.CloseDetectRequest" :decoder pb->CloseDetectRequest})

;-----------------------------------------------------------------------------
; FlowControlRequest
;-----------------------------------------------------------------------------
(defrecord FlowControlRequest-record [count payload-size]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Int32 1  {:optimize true} (:count this) os)
    (serdes.core/write-Int32 2  {:optimize true} (:payload-size this) os))
  pb/TypeReflection
  (gettype [this]
    "protojure.test.grpc.FlowControlRequest"))

(s/def :protojure.test.grpc.FlowControlRequest/count int?)
(s/def :protojure.test.grpc.FlowControlRequest/payload-size int?)
(s/def ::FlowControlRequest-spec (s/keys :opt-un [:protojure.test.grpc.FlowControlRequest/count :protojure.test.grpc.FlowControlRequest/payload-size ]))
(def FlowControlRequest-defaults {:count 0 :payload-size 0 })

(defn cis->FlowControlRequest
  "CodedInputStream to FlowControlRequest"
  [is]
  (->> (tag-map FlowControlRequest-defaults
         (fn [tag index]
             (case index
               1 [:count (serdes.core/cis->Int32 is)]
               2 [:payload-size (serdes.core/cis->Int32 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->FlowControlRequest-record)))

(defn ecis->FlowControlRequest
  "Embedded CodedInputStream to FlowControlRequest"
  [is]
  (serdes.core/cis->embedded cis->FlowControlRequest is))

(defn new-FlowControlRequest
  "Creates a new instance from a map, similar to map->FlowControlRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::FlowControlRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::FlowControlRequest-spec init))))]}
  (-> (merge FlowControlRequest-defaults init)
      (map->FlowControlRequest-record)))

(defn pb->FlowControlRequest
  "Protobuf to FlowControlRequest"
  [input]
  (cis->FlowControlRequest (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record FlowControlRequest-meta {:type "protojure.test.grpc.FlowControlRequest" :decoder pb->FlowControlRequest})

;-----------------------------------------------------------------------------
; FlowControlPayload
;-----------------------------------------------------------------------------
(defrecord FlowControlPayload-record [id data]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Int32 1  {:optimize true} (:id this) os)
    (serdes.core/write-Bytes 2  {:optimize true} (:data this) os))
  pb/TypeReflection
  (gettype [this]
    "protojure.test.grpc.FlowControlPayload"))

(s/def :protojure.test.grpc.FlowControlPayload/id int?)
(s/def :protojure.test.grpc.FlowControlPayload/data bytes?)
(s/def ::FlowControlPayload-spec (s/keys :opt-un [:protojure.test.grpc.FlowControlPayload/id :protojure.test.grpc.FlowControlPayload/data ]))
(def FlowControlPayload-defaults {:id 0 :data (byte-array 0) })

(defn cis->FlowControlPayload
  "CodedInputStream to FlowControlPayload"
  [is]
  (->> (tag-map FlowControlPayload-defaults
         (fn [tag index]
             (case index
               1 [:id (serdes.core/cis->Int32 is)]
               2 [:data (serdes.core/cis->Bytes is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->FlowControlPayload-record)))

(defn ecis->FlowControlPayload
  "Embedded CodedInputStream to FlowControlPayload"
  [is]
  (serdes.core/cis->embedded cis->FlowControlPayload is))

(defn new-FlowControlPayload
  "Creates a new instance from a map, similar to map->FlowControlPayload except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::FlowControlPayload-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::FlowControlPayload-spec init))))]}
  (-> (merge FlowControlPayload-defaults init)
      (map->FlowControlPayload-record)))

(defn pb->FlowControlPayload
  "Protobuf to FlowControlPayload"
  [input]
  (cis->FlowControlPayload (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record FlowControlPayload-meta {:type "protojure.test.grpc.FlowControlPayload" :decoder pb->FlowControlPayload})

;-----------------------------------------------------------------------------
; SimpleResponse
;-----------------------------------------------------------------------------
(defrecord SimpleResponse-record [msg]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:msg this) os))
  pb/TypeReflection
  (gettype [this]
    "protojure.test.grpc.SimpleResponse"))

(s/def :protojure.test.grpc.SimpleResponse/msg string?)
(s/def ::SimpleResponse-spec (s/keys :opt-un [:protojure.test.grpc.SimpleResponse/msg ]))
(def SimpleResponse-defaults {:msg "" })

(defn cis->SimpleResponse
  "CodedInputStream to SimpleResponse"
  [is]
  (->> (tag-map SimpleResponse-defaults
         (fn [tag index]
             (case index
               1 [:msg (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->SimpleResponse-record)))

(defn ecis->SimpleResponse
  "Embedded CodedInputStream to SimpleResponse"
  [is]
  (serdes.core/cis->embedded cis->SimpleResponse is))

(defn new-SimpleResponse
  "Creates a new instance from a map, similar to map->SimpleResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::SimpleResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::SimpleResponse-spec init))))]}
  (-> (merge SimpleResponse-defaults init)
      (map->SimpleResponse-record)))

(defn pb->SimpleResponse
  "Protobuf to SimpleResponse"
  [input]
  (cis->SimpleResponse (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record SimpleResponse-meta {:type "protojure.test.grpc.SimpleResponse" :decoder pb->SimpleResponse})

;-----------------------------------------------------------------------------
; ErrorRequest
;-----------------------------------------------------------------------------
(defrecord ErrorRequest-record [status message]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Int32 1  {:optimize true} (:status this) os)
    (serdes.core/write-String 2  {:optimize true} (:message this) os))
  pb/TypeReflection
  (gettype [this]
    "protojure.test.grpc.ErrorRequest"))

(s/def :protojure.test.grpc.ErrorRequest/status int?)
(s/def :protojure.test.grpc.ErrorRequest/message string?)
(s/def ::ErrorRequest-spec (s/keys :opt-un [:protojure.test.grpc.ErrorRequest/status :protojure.test.grpc.ErrorRequest/message ]))
(def ErrorRequest-defaults {:status 0 :message "" })

(defn cis->ErrorRequest
  "CodedInputStream to ErrorRequest"
  [is]
  (->> (tag-map ErrorRequest-defaults
         (fn [tag index]
             (case index
               1 [:status (serdes.core/cis->Int32 is)]
               2 [:message (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ErrorRequest-record)))

(defn ecis->ErrorRequest
  "Embedded CodedInputStream to ErrorRequest"
  [is]
  (serdes.core/cis->embedded cis->ErrorRequest is))

(defn new-ErrorRequest
  "Creates a new instance from a map, similar to map->ErrorRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ErrorRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ErrorRequest-spec init))))]}
  (-> (merge ErrorRequest-defaults init)
      (map->ErrorRequest-record)))

(defn pb->ErrorRequest
  "Protobuf to ErrorRequest"
  [input]
  (cis->ErrorRequest (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ErrorRequest-meta {:type "protojure.test.grpc.ErrorRequest" :decoder pb->ErrorRequest})

;-----------------------------------------------------------------------------
; BigPayload
;-----------------------------------------------------------------------------
(defrecord BigPayload-record [mode data]
  pb/Writer
  (serialize [this os]
    (write-BigPayload-Mode 1  {:optimize true} (:mode this) os)
    (serdes.core/write-Bytes 2  {:optimize true} (:data this) os))
  pb/TypeReflection
  (gettype [this]
    "protojure.test.grpc.BigPayload"))

(s/def :protojure.test.grpc.BigPayload/mode (s/or :keyword keyword? :int int?))
(s/def :protojure.test.grpc.BigPayload/data bytes?)
(s/def ::BigPayload-spec (s/keys :opt-un [:protojure.test.grpc.BigPayload/mode :protojure.test.grpc.BigPayload/data ]))
(def BigPayload-defaults {:mode BigPayload-Mode-default :data (byte-array 0) })

(defn cis->BigPayload
  "CodedInputStream to BigPayload"
  [is]
  (->> (tag-map BigPayload-defaults
         (fn [tag index]
             (case index
               1 [:mode (cis->BigPayload-Mode is)]
               2 [:data (serdes.core/cis->Bytes is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->BigPayload-record)))

(defn ecis->BigPayload
  "Embedded CodedInputStream to BigPayload"
  [is]
  (serdes.core/cis->embedded cis->BigPayload is))

(defn new-BigPayload
  "Creates a new instance from a map, similar to map->BigPayload except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::BigPayload-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::BigPayload-spec init))))]}
  (-> (merge BigPayload-defaults init)
      (map->BigPayload-record)))

(defn pb->BigPayload
  "Protobuf to BigPayload"
  [input]
  (cis->BigPayload (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record BigPayload-meta {:type "protojure.test.grpc.BigPayload" :decoder pb->BigPayload})

;-----------------------------------------------------------------------------
; ShouldThrowRequest
;-----------------------------------------------------------------------------
(defrecord ShouldThrowRequest-record [case]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Int32 1  {:optimize true} (:case this) os))
  pb/TypeReflection
  (gettype [this]
    "protojure.test.grpc.ShouldThrowRequest"))

(s/def :protojure.test.grpc.ShouldThrowRequest/case int?)
(s/def ::ShouldThrowRequest-spec (s/keys :opt-un [:protojure.test.grpc.ShouldThrowRequest/case ]))
(def ShouldThrowRequest-defaults {:case 0 })

(defn cis->ShouldThrowRequest
  "CodedInputStream to ShouldThrowRequest"
  [is]
  (->> (tag-map ShouldThrowRequest-defaults
         (fn [tag index]
             (case index
               1 [:case (serdes.core/cis->Int32 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ShouldThrowRequest-record)))

(defn ecis->ShouldThrowRequest
  "Embedded CodedInputStream to ShouldThrowRequest"
  [is]
  (serdes.core/cis->embedded cis->ShouldThrowRequest is))

(defn new-ShouldThrowRequest
  "Creates a new instance from a map, similar to map->ShouldThrowRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ShouldThrowRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ShouldThrowRequest-spec init))))]}
  (-> (merge ShouldThrowRequest-defaults init)
      (map->ShouldThrowRequest-record)))

(defn pb->ShouldThrowRequest
  "Protobuf to ShouldThrowRequest"
  [input]
  (cis->ShouldThrowRequest (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ShouldThrowRequest-meta {:type "protojure.test.grpc.ShouldThrowRequest" :decoder pb->ShouldThrowRequest})

;-----------------------------------------------------------------------------
; ShouldThrowResponse
;-----------------------------------------------------------------------------
(defrecord ShouldThrowResponse-record [numbers]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-Int32 1 (:numbers this) os))
  pb/TypeReflection
  (gettype [this]
    "protojure.test.grpc.ShouldThrowResponse"))

(s/def :protojure.test.grpc.ShouldThrowResponse/numbers (s/every int?))
(s/def ::ShouldThrowResponse-spec (s/keys :opt-un [:protojure.test.grpc.ShouldThrowResponse/numbers ]))
(def ShouldThrowResponse-defaults {:numbers [] })

(defn cis->ShouldThrowResponse
  "CodedInputStream to ShouldThrowResponse"
  [is]
  (->> (tag-map ShouldThrowResponse-defaults
         (fn [tag index]
             (case index
               1 [:numbers (serdes.complex/cis->packablerepeated tag serdes.core/cis->Int32 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ShouldThrowResponse-record)))

(defn ecis->ShouldThrowResponse
  "Embedded CodedInputStream to ShouldThrowResponse"
  [is]
  (serdes.core/cis->embedded cis->ShouldThrowResponse is))

(defn new-ShouldThrowResponse
  "Creates a new instance from a map, similar to map->ShouldThrowResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ShouldThrowResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ShouldThrowResponse-spec init))))]}
  (-> (merge ShouldThrowResponse-defaults init)
      (map->ShouldThrowResponse-record)))

(defn pb->ShouldThrowResponse
  "Protobuf to ShouldThrowResponse"
  [input]
  (cis->ShouldThrowResponse (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ShouldThrowResponse-meta {:type "protojure.test.grpc.ShouldThrowResponse" :decoder pb->ShouldThrowResponse})

