;;;----------------------------------------------------------------------------------
;;; Generated by protoc-gen-clojure.  DO NOT EDIT
;;;
;;; Message Implementation of package com.example.addressbook
;;;----------------------------------------------------------------------------------
(ns com.example.addressbook
  (:require [protojure.protobuf.protocol :as pb]
            [protojure.protobuf.serdes.core :as serdes.core]
            [protojure.protobuf.serdes.complex :as serdes.complex]
            [protojure.protobuf.serdes.utils :refer [tag-map]]
            [protojure.protobuf.serdes.stream :as serdes.stream]
            [clojure.set :as set]
            [clojure.spec.alpha :as s]))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Forward declarations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(declare cis->Person)
(declare ecis->Person)
(declare new-Person)
(declare cis->Person-PhoneNumber)
(declare ecis->Person-PhoneNumber)
(declare new-Person-PhoneNumber)
(declare cis->AddressBook)
(declare ecis->AddressBook)
(declare new-AddressBook)

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Enumerations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; Person-PhoneType
;-----------------------------------------------------------------------------
(def Person-PhoneType-default :mobile)

(def Person-PhoneType-val2label {0 :mobile
                                 1 :home
                                 2 :work})

(def Person-PhoneType-label2val (set/map-invert Person-PhoneType-val2label))

(defn cis->Person-PhoneType [is]
  (let [val (serdes.core/cis->Enum is)]
    (get Person-PhoneType-val2label val val)))

(defn- get-Person-PhoneType [value]
  {:pre [(or (int? value) (contains? Person-PhoneType-label2val value))]}
  (get Person-PhoneType-label2val value value))

(defn write-Person-PhoneType
  ([tag value os] (write-Person-PhoneType tag {:optimize false} value os))
  ([tag options value os]
   (serdes.core/write-Enum tag options (get-Person-PhoneType value) os)))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Message Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; Person
;-----------------------------------------------------------------------------

(defrecord Person-record [name id email phones]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:name this) os)
    (serdes.core/write-Int32 2  {:optimize true} (:id this) os)
    (serdes.core/write-String 3  {:optimize true} (:email this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 4 (:phones this) os))
  pb/TypeReflection
  (gettype [this]
    "com.example.addressbook.Person"))

(s/def :com.example.addressbook.Person/name string?)
(s/def :com.example.addressbook.Person/id int?)
(s/def :com.example.addressbook.Person/email string?)

(s/def ::Person-spec (s/keys :opt-un [:com.example.addressbook.Person/name :com.example.addressbook.Person/id :com.example.addressbook.Person/email]))
(def Person-defaults {:name "" :id 0 :email "" :phones []})

(defn cis->Person
  "CodedInputStream to Person"
  [is]
  (->> (tag-map Person-defaults
                (fn [tag index]
                  (case index
                    1 [:name (serdes.core/cis->String is)]
                    2 [:id (serdes.core/cis->Int32 is)]
                    3 [:email (serdes.core/cis->String is)]
                    4 [:phones (serdes.complex/cis->repeated ecis->Person-PhoneNumber is)]

                    [index (serdes.core/cis->undefined tag is)]))
                is)
       (map->Person-record)))

(defn ecis->Person
  "Embedded CodedInputStream to Person"
  [is]
  (serdes.core/cis->embedded cis->Person is))

(defn new-Person
  "Creates a new instance from a map, similar to map->Person except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Person-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Person-spec init))))]}
  (-> (merge Person-defaults init)
      (cond-> (some? (get init :phones)) (update :phones #(map new-Person-PhoneNumber %)))
      (map->Person-record)))

(defn pb->Person
  "Protobuf to Person"
  [input]
  (cis->Person (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Person-meta {:type "com.example.addressbook.Person" :decoder pb->Person})

;-----------------------------------------------------------------------------
; Person-PhoneNumber
;-----------------------------------------------------------------------------
(defrecord Person-PhoneNumber-record [number type]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:number this) os)
    (write-Person-PhoneType 2  {:optimize true} (:type this) os))
  pb/TypeReflection
  (gettype [this]
    "com.example.addressbook.Person-PhoneNumber"))

(s/def :com.example.addressbook.Person-PhoneNumber/number string?)
(s/def :com.example.addressbook.Person-PhoneNumber/type (s/or :keyword keyword? :int int?))
(s/def ::Person-PhoneNumber-spec (s/keys :opt-un [:com.example.addressbook.Person-PhoneNumber/number :com.example.addressbook.Person-PhoneNumber/type]))
(def Person-PhoneNumber-defaults {:number "" :type Person-PhoneType-default})

(defn cis->Person-PhoneNumber
  "CodedInputStream to Person-PhoneNumber"
  [is]
  (->> (tag-map Person-PhoneNumber-defaults
                (fn [tag index]
                  (case index
                    1 [:number (serdes.core/cis->String is)]
                    2 [:type (cis->Person-PhoneType is)]

                    [index (serdes.core/cis->undefined tag is)]))
                is)
       (map->Person-PhoneNumber-record)))

(defn ecis->Person-PhoneNumber
  "Embedded CodedInputStream to Person-PhoneNumber"
  [is]
  (serdes.core/cis->embedded cis->Person-PhoneNumber is))

(defn new-Person-PhoneNumber
  "Creates a new instance from a map, similar to map->Person-PhoneNumber except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Person-PhoneNumber-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Person-PhoneNumber-spec init))))]}
  (-> (merge Person-PhoneNumber-defaults init)
      (map->Person-PhoneNumber-record)))

(defn pb->Person-PhoneNumber
  "Protobuf to Person-PhoneNumber"
  [input]
  (cis->Person-PhoneNumber (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Person-PhoneNumber-meta {:type "com.example.addressbook.Person-PhoneNumber" :decoder pb->Person-PhoneNumber})

;-----------------------------------------------------------------------------
; AddressBook
;-----------------------------------------------------------------------------
(defrecord AddressBook-record [people]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-embedded 1 (:people this) os))
  pb/TypeReflection
  (gettype [this]
    "com.example.addressbook.AddressBook"))

(s/def ::AddressBook-spec (s/keys :opt-un []))
(def AddressBook-defaults {:people []})

(defn cis->AddressBook
  "CodedInputStream to AddressBook"
  [is]
  (->> (tag-map AddressBook-defaults
                (fn [tag index]
                  (case index
                    1 [:people (serdes.complex/cis->repeated ecis->Person is)]

                    [index (serdes.core/cis->undefined tag is)]))
                is)
       (map->AddressBook-record)))

(defn ecis->AddressBook
  "Embedded CodedInputStream to AddressBook"
  [is]
  (serdes.core/cis->embedded cis->AddressBook is))

(defn new-AddressBook
  "Creates a new instance from a map, similar to map->AddressBook except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AddressBook-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AddressBook-spec init))))]}
  (-> (merge AddressBook-defaults init)
      (cond-> (some? (get init :people)) (update :people #(map new-Person %)))
      (map->AddressBook-record)))

(defn pb->AddressBook
  "Protobuf to AddressBook"
  [input]
  (cis->AddressBook (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record AddressBook-meta {:type "com.example.addressbook.AddressBook" :decoder pb->AddressBook})

