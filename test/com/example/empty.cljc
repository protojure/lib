;;;----------------------------------------------------------------------------------
;;; Generated by protoc-gen-clojure.  DO NOT EDIT
;;;
;;; Message Implementation of package com.example.empty
;;;----------------------------------------------------------------------------------
(ns com.example.empty
  (:require [protojure.protobuf.protocol :as pb]
            [protojure.protobuf.serdes.core :as serdes.core]
            [protojure.protobuf.serdes.complex :as serdes.complex]
            [protojure.protobuf.serdes.utils :refer [tag-map]]
            [protojure.protobuf.serdes.stream :as serdes.stream]
            [clojure.set :as set]
            [clojure.spec.alpha :as s]))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Forward declarations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(declare cis->Empty)
(declare ecis->Empty)
(declare new-Empty)
(declare cis->NonEmpty)
(declare ecis->NonEmpty)
(declare new-NonEmpty)
(declare cis->Selection)
(declare ecis->Selection)
(declare new-Selection)
(declare cis->Container)
(declare ecis->Container)
(declare new-Container)

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; opt's oneof Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(defn convert-opt [origkeyval]
  (cond
     (get-in origkeyval [:opt :e]) (update-in origkeyval [:opt :e] new-Empty)
     (get-in origkeyval [:opt :ne]) (update-in origkeyval [:opt :ne] new-NonEmpty)
     :default origkeyval))

(defn write-opt [opt os]
  (let [field (first opt)
        k (when-not (nil? field) (key field))
        v (when-not (nil? field) (val field))]
     (case k
         :e (serdes.core/write-embedded 1 v os)
         :ne (serdes.core/write-embedded 2 v os)
         nil)))



;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Message Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; Empty
;-----------------------------------------------------------------------------
(defrecord Empty-record []
  pb/Writer
  (serialize [this os]
)
  pb/TypeReflection
  (gettype [this]
    "com.example.empty.Empty"))

(s/def ::Empty-spec (s/keys :opt-un []))
(def Empty-defaults {})

(defn cis->Empty
  "CodedInputStream to Empty"
  [is]
  (->> (tag-map Empty-defaults
         (fn [tag index]
             (case index
               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Empty-record)))

(defn ecis->Empty
  "Embedded CodedInputStream to Empty"
  [is]
  (serdes.core/cis->embedded cis->Empty is))

(defn new-Empty
  "Creates a new instance from a map, similar to map->Empty except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Empty-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Empty-spec init))))]}
  (-> (merge Empty-defaults init)
      (map->Empty-record)))

(defn pb->Empty
  "Protobuf to Empty"
  [input]
  (cis->Empty (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Empty-meta {:type "com.example.empty.Empty" :decoder pb->Empty})

;-----------------------------------------------------------------------------
; NonEmpty
;-----------------------------------------------------------------------------
(defrecord NonEmpty-record [i]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Int32 1  {:optimize true} (:i this) os))
  pb/TypeReflection
  (gettype [this]
    "com.example.empty.NonEmpty"))

(s/def :com.example.empty.NonEmpty/i int?)
(s/def ::NonEmpty-spec (s/keys :opt-un [:com.example.empty.NonEmpty/i ]))
(def NonEmpty-defaults {:i 0 })

(defn cis->NonEmpty
  "CodedInputStream to NonEmpty"
  [is]
  (->> (tag-map NonEmpty-defaults
         (fn [tag index]
             (case index
               1 [:i (serdes.core/cis->Int32 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->NonEmpty-record)))

(defn ecis->NonEmpty
  "Embedded CodedInputStream to NonEmpty"
  [is]
  (serdes.core/cis->embedded cis->NonEmpty is))

(defn new-NonEmpty
  "Creates a new instance from a map, similar to map->NonEmpty except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::NonEmpty-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::NonEmpty-spec init))))]}
  (-> (merge NonEmpty-defaults init)
      (map->NonEmpty-record)))

(defn pb->NonEmpty
  "Protobuf to NonEmpty"
  [input]
  (cis->NonEmpty (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record NonEmpty-meta {:type "com.example.empty.NonEmpty" :decoder pb->NonEmpty})

;-----------------------------------------------------------------------------
; Selection
;-----------------------------------------------------------------------------
(defrecord Selection-record [opt]
  pb/Writer
  (serialize [this os]
    (write-opt  (:opt this) os))
  pb/TypeReflection
  (gettype [this]
    "com.example.empty.Selection"))

(s/def ::Selection-spec (s/keys :opt-un []))
(def Selection-defaults {})

(defn cis->Selection
  "CodedInputStream to Selection"
  [is]
  (->> (tag-map Selection-defaults
         (fn [tag index]
             (case index
               1 [:opt {:e (ecis->Empty is)}]
               2 [:opt {:ne (ecis->NonEmpty is)}]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Selection-record)))

(defn ecis->Selection
  "Embedded CodedInputStream to Selection"
  [is]
  (serdes.core/cis->embedded cis->Selection is))

(defn new-Selection
  "Creates a new instance from a map, similar to map->Selection except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Selection-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Selection-spec init))))]}
  (-> (merge Selection-defaults init)
      (convert-opt)
      (map->Selection-record)))

(defn pb->Selection
  "Protobuf to Selection"
  [input]
  (cis->Selection (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Selection-meta {:type "com.example.empty.Selection" :decoder pb->Selection})

;-----------------------------------------------------------------------------
; Container
;-----------------------------------------------------------------------------
(defrecord Container-record [e ne]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:e this) os)
    (serdes.core/write-embedded 2 (:ne this) os))
  pb/TypeReflection
  (gettype [this]
    "com.example.empty.Container"))

(s/def ::Container-spec (s/keys :opt-un []))
(def Container-defaults {})

(defn cis->Container
  "CodedInputStream to Container"
  [is]
  (->> (tag-map Container-defaults
         (fn [tag index]
             (case index
               1 [:e (ecis->Empty is)]
               2 [:ne (ecis->NonEmpty is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Container-record)))

(defn ecis->Container
  "Embedded CodedInputStream to Container"
  [is]
  (serdes.core/cis->embedded cis->Container is))

(defn new-Container
  "Creates a new instance from a map, similar to map->Container except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Container-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Container-spec init))))]}
  (-> (merge Container-defaults init)
      (cond-> (some? (get init :e)) (update :e new-Empty))
      (cond-> (some? (get init :ne)) (update :ne new-NonEmpty))
      (map->Container-record)))

(defn pb->Container
  "Protobuf to Container"
  [input]
  (cis->Container (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Container-meta {:type "com.example.empty.Container" :decoder pb->Container})

